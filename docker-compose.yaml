# docker-compose.yml (Updated and Corrected)

services:
  # 1. Database and Broker Services (No major changes)
  db:
    image: postgres:16-alpine
    volumes:
      - pnm_data:/var/lib/postgresql/data/
    env_file:
      - ./.env
    # The 'healthcheck' is a good practice to ensure the DB is truly ready
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $$POSTGRES_USER -d $$POSTGRES_DB"]
      interval: 5s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    restart: always
    # No need to expose Redis port to the host machine unless you want to connect from outside Docker
    # ports:
    #   - "6379:6379"

  # 2. One-Time Setup Service
  # This service runs first, applies migrations, and then exits.
  migrate:
    build: .
    # This command now includes collectstatic as well.
    command: sh -c "python manage.py migrate --noinput && python manage.py collectstatic --noinput"
    volumes:
      - static_data:/app/static_root
      - .:/app
    env_file:
      - ./.env
    depends_on:
      db:
        # It will wait for the database to pass its healthcheck before running.
        condition: service_healthy
      redis:
        # Redis starts fast, so a simple 'service_started' is fine.
        condition: service_started

  # 3. Long-Running Application Services
  # These services will only start AFTER the 'migrate' service has finished successfully.
  web:
    build: .
    # The command is now simplified to only run the server.
    # Use gunicorn for production instead of runserver for better performance.
    command: gunicorn pythonnetworkmonitor.wsgi:application --bind 0.0.0.0:8000
    volumes:
      - static_data:/app/static_root
      - .:/app
#    ports:
#      - "8000:8000"
    env_file:
      - ./.env
    depends_on:
      migrate:
        # This is the key: it waits for the 'migrate' service to complete.
        condition: service_completed_successfully

  nginx:
      build:
        context: .
        dockerfile: Dockerfile.nginx
      ports:
        # Expose port 80 to the world
        - "80:80"
      volumes:
        # Nginx needs to read from the shared static volume
        - static_data:/app/static_root
      depends_on:
        - web


  worker:
    build: .
    command: celery -A pythonnetworkmonitor worker -l info
    volumes:
      - .:/app
    env_file:
      - ./.env
    depends_on:
      migrate:
        condition: service_completed_successfully

  celery-beat:
    build: .
    # Corrected a small typo in the scheduler path (. instead of ..)
    command: celery -A pythonnetworkmonitor beat -l info --scheduler django_celery_beat.schedulers:DatabaseScheduler
    volumes:
      # Changed this to /app to be consistent with other services.
      - .:/app
    env_file:
      - ./.env
    depends_on:
      migrate:
        condition: service_completed_successfully

volumes:
  pnm_data:
  static_data: